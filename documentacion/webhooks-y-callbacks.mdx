---
title: "游뿧 Webhooks, Estados y Callbacks"
description: "C칩mo sabes lo que nosotros sabemos."
---

Las transacciones de Koywe siguen un camino (principalmente) lineal: se crean, se pagan y se entregan.
Todo esto se notifica a trav칠s de webhooks (ver m치s abajo) o se devuelve cuando llamas a nuestras APIs
para hacer seguimiento a una orden.

Los posibles estados de una orden son:

- `WAITING`: La orden ha sido creada y est치 esperando a ser pagada.

- `PENDING`: La orden ha sido pagada y est치 en cola para su ejecuci칩n.

- `EXECUTING`: La orden est치 siendo ejecutada. es decir: La transacci칩n se est치 enviando a la blockchain o al banco.

- `IN_PROGRESS`: Los fondos, ya sean criptos o fiat, est치n en camino a su destino.

- `INVALID_WITHDRAWALS_DETAILS`: Solo v치lido para las rampas de salida. Los datos bancarios eran incorrectos y el banco de destino ha rechazado la transferencia.

- `REJECTED`: La orden ha sido rechazada por el usuario o el procesador de pagos.

- `DELIVERED`: Los fondos, ya sean criptos o fiat, han sido entregados con 칠xito.

### Webhook de Eventos

Para facilitar la integraci칩n, tenemos la posibilidad de alertarte cuando pasa
algo o de definir formas de validar ciertas cosas contigo antes de ejecutar las
transacciones.

Puedes configurar una URL para recibir solicitudes cada vez que se activa un evento para una transacci칩n. Los posibles eventos
son:

`payment_created`: se crea la orden, Koywe espera el pago en fiat o en cripto. El estado de la orden ser치 `WAITING`.

`payment_received`: se paga la orden. Koywe confirma el pago con 칠xito y entregar치 `amountOut`. El estado de la orden ser치 `PENDING`.

`payment_rejected`: se rechaza la orden. Algo sucedi칩 y se rechaz칩 la orden. Este evento NO se env칤a para las transferencias
bancarias y normalmente se debe a un error o cancelaci칩n por parte del usuario. El estado de la orden ser치 `REJECTED`.

`payment_expired`: la orden ha expirado. Solo se env칤a para las transferencias bancarias. El usuario tard칩 demasiado
en transferir o Koywe no pudo detectar el pago a tiempo. Se deber칤a crear otra orden o cotizaci칩n para asegurar un precio.
El estado de la orden ser치 `REJECTED`.

Eventos espec칤ficos de onramp:

`crypto_tx_sent`: se env칤a la transacci칩n criptogr치fica despu칠s de que se confirma el pago en fiat. El estado de la orden ser치 `IN_PROGRESS`.

`crypto_delivered`: la transacci칩n criptogr치fica es confirmada por la cadena de bloques. El estado de la orden ser치 `DELIVERED`.

`crypto_tx_failed`: la transacci칩n criptogr치fica fall칩. Esto <i>no deber칤a</i> suceder, pero ocurre en algunos casos
m칤nimos (1 de cada 10 mil). Si llegara a suceder, intentar칤amos la transacci칩n nuevamente y volver칤as a recibir los
eventos de m치s arriba. El estado de la orden ser치 `REJECTED`.

Eventos espec칤ficos de offramp:

`fiat_sent`: se env칤a la transferencia en fiat desde la cuenta de Koywe. El estado de la orden ser치 `IN_PROGRESS`.

`fiat_delivered`: el fiat se entrega, seg칰n el banco de Koywe. El estado de la orden ser치 `DELIVERED`.

`invalid_withdrawals_details`: se intent칩 la transferencia en fiat, pero el banco rechaz칩 la transacci칩n porque la cuenta
o el due침o de la cuenta no coincid칤an con los registros existentes. Hay un endpoint especial para corregir los datos de la
transacci칩n, puedes revisarlo en los docs de la API. El estado de la orden ser치 `INVALID_WITHDRAWALS_DETAILS`.

Adicionalmente, podr치s definir un `secret` para validar que somos nosotros
quienes estamos enviando esos requests. Usando ese secret, encriptamos los
par치metros enviados y agregamos el hash para que puedas verificar el mensaje:

```js
const signature \= crypto.createHmac('sha256',
secret).update(JSON.stringify(payload)).digest('hex')
```

Ejemplo de evento reportado:

```json
{
  "eventName": "crypto_delivered", // event, from the list above
  "orderId": "5a3288ea-0bd4-44d2-af11-aae1f88bbd61", // order id, see above
  "timeStamp": "2022-10-26T22:36:41.658Z",
  "signature": "ed40d34ab7a587cf1a16338a16cc7765ae4420936677482bb33f5f738e4f7189" // hash
}
```

### Callback de Autenticaci칩n

Podr치s definir una URL en tu API que nos confirme que un usuario puede operar en
tu contexto de cliente. De esta forma, cada vez que un usuario quiera comprar,
vender, o revisar informaci칩n privada, revisaremos contigo antes de dejarlo
actuar.

Nuestra plataforma asume que devolver치s _algo_ que se parezca a un booleano
positivo y soporta varios m칠todos de autenticaci칩n.

<Warning>
  Por defecto, vamos a usar el m칠todo POST para llamar a tu API. Si necesitas algo distinto, h치znoslo saber.
</Warning>

```js
// usuario compra cripto
const createOrder (payload) {
    if (!validUser(payload.email)) throw new Error('user not allowed');
    else continue
}
// validamos contra tu API antes de dejarlo seguir
const validUser(email) {
    const payload = { email }
    const headers = { 'Authorization': 'Bearer superJWT' }
    const { data } = await axios.post(urlExternalAPI, payload, { headers })
    reurn data
}
```
