---
title: "游뿧 Webhooks y Callbacks"
description: "No nos busques, nosotros te llamaremos."
---

Para facilitar la integraci칩n, tenemos la posibilidad de alertarte cuando pasa
algo o de definir formas de validar ciertas cosas contigo antes de ejecutar las
transacciones.

### Webhook de Eventos

Puedes configurar una URL para recibir solicitudes cada vez que se activa un evento para una transacci칩n. Los posibles eventos
son:

`payment_created`: se crea la orden, Koywe espera el pago en fiat o en cripto.

`payment_received`: se paga la orden. Koywe confirma el pago con 칠xito y entregar치 la cantidadOut

`payment_rejected`: se rechaza la orden. Algo sucedi칩 y se rechaz칩 la orden. Este evento NO se env칤a para las transferencias
bancarias y normalmente se debe a un error o cancelaci칩n por parte del usuario.

`payment_expired`: la orden ha expirado. Solo se env칤a para las transferencias bancarias. El usuario tard칩 demasiado
en transferir o Koywe no pudo detectar el pago a tiempo. Se deber칤a crear otra orden o cotizaci칩n para asegurar un precio.

Eventos espec칤ficos de onramp:

`crypto_tx_sent`: se env칤a la transacci칩n criptogr치fica despu칠s de que se confirma el pago en fiat.

`crypto_delivered`: la transacci칩n criptogr치fica es confirmada por la cadena de bloques.

`crypto_tx_failed`: la transacci칩n criptogr치fica fall칩. Esto <i>no deber칤a</i> suceder, pero ocurre en algunos casos
m칤nimos (1 de cada 10 mil). Si llegara a suceder, intentar칤amos la transacci칩n nuevamente y volver칤as a recibir los
eventos de m치s arriba.

Eventos espec칤ficos de offramp:

`fiat_sent`: se env칤a la transferencia en fiat desde la cuenta de Koywe.

`fiat_delivered`: el fiat se entrega, seg칰n el banco de Koywe.

`invalid_withdrawals_details`: se intent칩 la transferencia en fiat, pero el banco rechaz칩 la transacci칩n porque la cuenta
o el due침o de la cuenta no coincid칤an con los registros existentes. Hay un endpoint especial para corregir los datos de la
transacci칩n, puedes revisarlo en los docs de la API.

Adicionalmente, podr치s definir un `secret` para validar que somos nosotros
quienes estamos enviando esos requests. Usando ese secret, encriptamos los
par치metros enviados y agregamos el hash para que puedas verificar el mensaje:

```js
const signature \= crypto.createHmac('sha256',
secret).update(JSON.stringify(payload)).digest('hex')
```

Ejemplo de evento reportado:

```json
{
  "eventName": "crypto_delivered", // event, from the list above
  "orderId": "5a3288ea-0bd4-44d2-af11-aae1f88bbd61", // order id, see above
  "timeStamp": "2022-10-26T22:36:41.658Z",
  "signature": "ed40d34ab7a587cf1a16338a16cc7765ae4420936677482bb33f5f738e4f7189" // hash
}
```

### Callback de Autenticaci칩n

Podr치s definir una URL en tu API que nos confirme que un usuario puede operar en
tu contexto de cliente. De esta forma, cada vez que un usuario quiera comprar,
vender, o revisar informaci칩n privada, revisaremos contigo antes de dejarlo
actuar.

Nuestra plataforma asume que devolver치s _algo_ que se parezca a un booleano
positivo y soporta varios m칠todos de autenticaci칩n.

<Warning>
  Por defecto, vamos a usar el m칠todo POST para llamar a tu API. Si necesitas algo distinto, h치znoslo saber.
</Warning>

```js
// usuario compra cripto
const createOrder (payload) {
    if (!validUser(payload.email)) throw new Error('user not allowed');
    else continue
}
// validamos contra tu API antes de dejarlo seguir
const validUser(email) {
    const payload = { email }
    const headers = { 'Authorization': 'Bearer superJWT' }
    const { data } = await axios.post(urlExternalAPI, payload, { headers })
    reurn data
}
```
